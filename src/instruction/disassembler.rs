use crate::instruction::Instruction;

impl Instruction {
    /// Convert instruction to assembly string
    pub fn to_assembly(&self) -> String {
        match self {
            Instruction::Halt => "halt".to_string(),
            Instruction::Nop => "nop".to_string(),
            Instruction::LoadImm { dest, value } => format!("loadimm {}, 0x{:x}", dest.name(), value),
            Instruction::Move { dest, src } => format!("move {}, {}", dest.name(), src.name()),
            Instruction::Swap { r1, r2 } => format!("swap {}, {}", r1.name(), r2.name()),
            Instruction::Add { dest, left, right } => format!("add {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Sub { dest, left, right } => format!("sub {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Mul { dest, left, right } => format!("mul {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Div { dest, left, right } => format!("div {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Mod { dest, left, right } => format!("mod {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::AddAssign { dest, src } => format!("addassign {}, {}", dest.name(), src.name()),
            Instruction::SubAssign { dest, src } => format!("subassign {}, {}", dest.name(), src.name()),
            Instruction::MulAssign { dest, src } => format!("mulassign {}, {}", dest.name(), src.name()),
            Instruction::DivAssign { dest, src } => format!("divassign {}, {}", dest.name(), src.name()),
            Instruction::And { dest, left, right } => format!("and {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Or { dest, left, right } => format!("or {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Xor { dest, left, right } => format!("xor {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Not { dest, src } => format!("not {}, {}", dest.name(), src.name()),
            Instruction::Shl { dest, left, right } => format!("shl {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Shr { dest, left, right } => format!("shr {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Push { src } => format!("push {}", src.name()),
            Instruction::Pop { dest } => format!("pop {}", dest.name()),
            Instruction::Peek { dest } => format!("peek {}", dest.name()),
            Instruction::Load { dest, addr_reg } => format!("load {}, [{}]", dest.name(), addr_reg.name()),
            Instruction::Store { src, addr_reg } => format!("store {}, [{}]", src.name(), addr_reg.name()),
            Instruction::LoadIndexed { dest, base_reg, index_reg } => format!("loadindexed {}, [{} + {} * 8]", dest.name(), base_reg.name(), index_reg.name()),
            Instruction::StoreIndexed { src, base_reg, index_reg } => format!("storeindexed {}, [{} + {} * 8]", src.name(), base_reg.name(), index_reg.name()),
            Instruction::Alloc { dest, size } => format!("alloc {}, {}", dest.name(), size.name()),
            Instruction::Free { ptr } => format!("free {}", ptr.name()),
            Instruction::MemCopy { dest, src, size } => format!("memcpy {}, {}, {}", dest.name(), src.name(), size.name()),
            Instruction::MemSet { dest, value, size } => format!("memset {}, {}, {}", dest.name(), value.name(), size.name()),
            Instruction::FAdd { dest, left, right } => format!("fadd {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::FSub { dest, left, right } => format!("fsub {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::FMul { dest, left, right } => format!("fmul {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::FDiv { dest, left, right } => format!("fdiv {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::FSqrt { dest, src } => format!("fsqrt {}, {}", dest.name(), src.name()),
            Instruction::FAbs { dest, src } => format!("fabs {}, {}", dest.name(), src.name()),
            Instruction::FNeg { dest, src } => format!("fneg {}, {}", dest.name(), src.name()),
            Instruction::F2I { dest, src } => format!("f2i {}, {}", dest.name(), src.name()),
            Instruction::I2F { dest, src } => format!("i2f {}, {}", dest.name(), src.name()),
            Instruction::FCmp { left, right } => format!("fcmp {}, {}", left.name(), right.name()),
            Instruction::PopCnt { dest, src } => format!("popcnt {}, {}", dest.name(), src.name()),
            Instruction::Clz { dest, src } => format!("clz {}, {}", dest.name(), src.name()),
            Instruction::Ctz { dest, src } => format!("ctz {}, {}", dest.name(), src.name()),
            Instruction::BSwap { dest, src } => format!("bswap {}, {}", dest.name(), src.name()),
            Instruction::RotL { dest, left, right } => format!("rotl {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::RotR { dest, left, right } => format!("rotr {}, {}, {}", dest.name(), left.name(), right.name()),
            Instruction::Jump { target } => format!("jump 0x{:x}", target),
            Instruction::Compare { left, right } => format!("compare {}, {}", left.name(), right.name()),
            Instruction::JumpIfZero { target } => format!("jz 0x{:x}", target),
            Instruction::JumpIfNotZero { target } => format!("jnz 0x{:x}", target),
            Instruction::JumpIfGt { target } => format!("jgt 0x{:x}", target),
            Instruction::JumpIfLt { target } => format!("jlt 0x{:x}", target),
            Instruction::JumpIfGe { target } => format!("jge 0x{:x}", target),
            Instruction::JumpIfLe { target } => format!("jle 0x{:x}", target),
            Instruction::JumpIfEq { target } => format!("jeq 0x{:x}", target),
            Instruction::JumpIfNe { target } => format!("jne 0x{:x}", target),
            Instruction::JumpIfAbove { target } => format!("ja 0x{:x}", target),
            Instruction::JumpIfBelow { target } => format!("jb 0x{:x}", target),
            Instruction::JumpIfAe { target } => format!("jae 0x{:x}", target),
            Instruction::JumpIfBe { target } => format!("jbe 0x{:x}", target),
            Instruction::Call { target } => format!("call 0x{:x}", target),
            Instruction::Return => "return".to_string(),
            Instruction::Syscall => "syscall".to_string(),
        }
    }
}
